<!DOCTYPE html>
<html>
<head>
	<title>
		Comandos GIT
	</title>
	<link rel="STYLESHEET" type="text/css" href="style.css"> 

</head>
<body>
	<div>
	<h2 >Estados de GIT</h2>
	<p>Existen tres esdados en GIT:</p>
	<ol>
		<li>Working Directory</li>
		<li>Staging Area</li>
		<li>Git repository</li>
	</ol>	
	</div>
	<div>
	<h2>Comandos Bash con GIT</h2>
 	<p>Los siguientes comandos pueden ser utilzados en la consola de GIT</p>
 	<dl>
 		<dt>GIT INIT</dt>
 		<dd>Inicializa un proyecto de GIT. SI se coloca un nombre despues de INIT se creara un nuevo repositorio con el nombre propuesto</dd>
 		<dt>GIT COMMIT -M "Mensaje a enviar":</dt>
 		<dd>Envia un commit para almacenar en el repositorio</dd>
 		<dt>GIT COMMIT --AMEND:</dt>
 		<dd>Agrega el contenido a un commit enviado con anterioridad</dd>
 		<dd>Se puede agregar un -m "mensaje" el cual remplazara el mesaje del commit anterior</dd>
 		<dt>GIT RM --CACHED  [ARCHIVO_NAME]</dt>
 		<dd>Se quitara el arhivo del Stating Area sin eliminar por completo el archivo</dd>
 		<dt>GIT RM -F [NOMBRE_ARCHIVO]</dt>
 		<dd>Elimina definitivamente el archivo</dd>
 	</dl>	
	</div>
 	
 	<div>
 	<h2>USO DE ETIQUETAS</h2>
 	<p>Sirve para etiquetar los cambios o versiones que ocurrieron. Es decir, despues de un commit. Existe de dos tipos las ligeras y anotadas</p>
 	<dl>
 		<dt>GIT TAG -a [version ej: 1.0] -m "DESCRIPCION"</dt>
 		<dd>Se agrega una etiqueta al estado en el que se encuentra el proyecto</dd>
 	</dl>
 	<p>otros comandos utiles:</p>
 	<ol>
 		<li>git tag -l: lista los tag creados</li>
 		<li>git tag -d [tag]: borra el tag existente</li>

 	</ol>	
 	</div>

 	<div>
 	<h2>GIT LOG</h2>
 	<P>A trav√©s de GIT LOG se puede ver multiple informacion sobre los secesos ocurridos en GiT</P>
 	<dl>
 		<dt>GIT LOG --ONELINE</dt>
 		<dd>Muestra solo los titulos de los commit.</dd>
 		<dt>GIT LOG --GRAPH</dt>
 		<dd>Muestra el grafico de los cambios ocurridos en las diferentes ramas</dd>
 	</dl>
 	<p><i>Se puede crear log personalizados mediante la documentacion de GIT LOG</i></p>
 	<p><small>
 		SUPERLOG: git config --global alias.superlog "log --graph --abbrev-commit --decorate --date=relative --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(bold yellow)%d%C(reset)' --all"

 	</small></p>	
 	</div>
 	
 	<div>
 	<h2>Comparar con DIFF</h2>
 	<p>Se puede comparar entre commit diferentes a traves del uso de GIT DIFF. La sintaxis es la siguientes:
 	git diff [nombre_log, num_commit o hash] [nombre_log, num_commit o hash]</p>
	
 	</div>
	<div>
	<h2>RESET EN GIT</h2>
 	<p>Existe tres tipos de reset: </p>
 	<ul>
 		<li>git reset --soft</li>
 		<li>git reset --mixed</li>
 		<li>git reset --hard</li>
 	</ul>
 	<dl>
 		<dt>
 			GIT RESET --SOFT:
 		</dt>
 		<dd>
 			Se debera establecer DESDE que commit se va a eliminar el ultimo commit. Pero la informacion
 			se mantiene en el stage, es decir, que solo se borro el commit mas no lo que se encuentra en el repositorio local. La estructura es siguiente: git reset --soft [hash]
 		</dd>
 		<dt>
 			GIT RESET --MIXED
 		</dt>
 		<dd>
 			Este comando borra la informacion subida al stating y del commit. Por lo tanto la informacion permace pero sin ser alamcenada en el repositorio local ni global. La informacion
 			queda en el working area.
 			<img src="git_reset.JPG">
 		</dd>
 		<dt> GIT RESET --HARD</dt>
 		<dd>Este comando elimina todo lo registrado en las tres fases de 
 		almacenamiento. Excepto lo que no se manipulo con el git</dd>
 	</dl>
 	<small><i>NOTA: Se puede recuperar lo eliminado. Pero para eso 
 	se necesita HASH de lo que se desea recuperar. Se recomienda almacenar
 	los LOG</i></small>
 		
	</div> 	
	<div>
	<h2>CONFIGURAR OTRO EDITOR PARA GIT</h2>
 	<p>La configuracion de otro editor sera util para facilir la edicion de texto. El comando es:</p>
 	<p><i>git congif --global core.edit "[nombre del editor] --wait" -> Wairt se utiliza para esperar hasta que el editor guarde los cambios</i></p>
 	<p><small>PARA WIN: git config --global core.editor"C:/Users/_USERNAME_/AppData/Local/atom/app-_VERSION_/atom.exe"</small></p>
 		
	</div>
 	<div>
 		<h2>RAMAS</h2>
 		<h2>Git BRACH</h2>
 		<ul>
 			<li>git brach [nombre de la rama]: <small>Crea una nueva rama</small></li>
 			<li>git brach -l: <small>Lista las ramas</small></li>
 			<li>git brach -d [nombre de la rama]: <small>elimina una rama</small></li>
 			<li>git brach -m [nombre anterior] [nuevoNombre]: <small>
 				para renombrar la rama
 			</small></li>
 		</ul>
 		<h2>MOVIENDONOS ENTRE REAMAS</h2>
 		<P>Para movernos entre ramas se emplea el comando 
 			<i>git checkout [nombre de la ram]</i>. Ademas se puede
 			mover a un commit sin alterar el codigo escrito: <i>git checkout [hash o nombre del commit]</i></P>
 			<p><i>SE PUEDE CREAR UNA RAMA A PARTIR DE UNA VERSION ANTERIRO mediante el uso de checkout [commit]. Para lo
 			cual se necesita git checkout -b [nombre de la rama]</i></p>
 	</div>
 	<div>
 		<h2>UNIR RAMAS</h2>
 		<p>Para unir las ramas se debe hacer un merge. Para lo cual se pude realizar a traves del siguiente comando: git merge [nombre de la rama], vale recordar que se debe posicionar en la rama que a la que se le va a agregar los cambios de la otra rama</p>
 		
 	</div>
 	<div>
 		<h2>GIT REBASE</h2>
 		<P>
 			Realiza la misma funcion que MERGE a diferencia que no crea ramas adicionales cuando existe conflictos. Es recomendable solo usar de manera local ya que traeria conflcitos al utilzar de manera online.. debe estar en la que se va a realizar la union. 

 		</P>
 		<p>Se puede decir que se trata de reorganizar los commit. Con el comando git rebase, puedes coger todos los cambios confirmados en una rama, y reaplicarlos sobre otra.
 		</p>
 		<p>comadno: git rebase rama_a_unir</p> <a href="https://git-scm.com/book/es/v1/Ramificaciones-en-Git-Reorganizando-el-trabajo-realizado">ver mas info</a>
 	</div>
 	<div>
 		<h2>GUARDAR CAMBIOS TEMPORALES</h2>
 		<p>Sirve para guardar temporalmente los cambios antes de hacer un merge. Despues de guardar se puede mover entre ramas sin problemas. Se debe aplicar el stash para continuar con la programacion</p>
 		<ul>
 			<li>git stash : Guarda en el limbo</li>
 			<li>git stash list : lista todos los stach guardados</li>
 			<li>git stash apply [stash{num}]</li>
 		</ul>
  	</div>
  	<div>
  		<h2>MOVIENDO COMMIT ENTRE RAMAS </h2>
  		<P>Para mover uncommit entre ramas es necesario el comando: <strong>git commit cherry-pick [hash del commit]</strong>. Recuerde que para esto es necesario copiar el hash que se encuetra en la rama que va a mover el has despues moverse a la rama donde quiere el commit y ejecutar el comando</P>
  	</div>
  	<div>
  		<h2>GITHUB</h2>
  		<p>Lenguaje de marcado: </p>
  	</div>
</body>
<footer>
	<h3>Comandos de consola LINUX</h3>
	<ul>
		<li>Crear un archiv: touch nombre_Archivo</li>
	</ul>
</footer>
</html>
